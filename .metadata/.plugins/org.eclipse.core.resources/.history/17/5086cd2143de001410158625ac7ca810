import java.util.List;


public class JobTrackerAssigner implements Runnable {
	private Thread t;
	ZkConnector zkc;
	List<String> list;
	String task;
	String assignPath;
	public JobTrackerAssigner(String task, String assignPath, List<String> listOfAssign, ZkConnector zkc)
	{
		this.task = task;
		this.list = listOfAssign;
		this.zkc = zkc;
		String assignPath = assignPath;
	}

	@Override
	public void run() {
		// TODO Auto-generated method stub
		while (true)
		{
			for (String s : list)
			{
				//zkc.update(assignPath + "/" + list.get(0), task.getBytes());
				
				// check and see if worker available
				String fullAssignPath = assignPath + "/" + s;
				byte[] data = zkc.read(fullAssignPath);
				
				if (data== null)
				{
					// available worker found, assign job
					task = password + "-" + partitionID + "-" +partitionSize;
					System.out.println(">>> assign task: " + task + "to " + fullAssignPath);
					zkc.update(fullAssignPath, task.getBytes());
					partitionID ++;
					// worker finish -> job tracker clear assign
					// allow enough time for the worker to up the watch again
					// avoid the case when the assign is cleared to null, while the user's watch is down
					// another task is assigned - in this case the worker will miss the task being assigned.
					// take a 1 second break for the worker to up the watch again.
					Thread.sleep(1000);
				}
			}
			
			// if 2 works, id = 0, 1, split job in half
			// both works got task, then partitionID = 1
			// (partitionID + 1) == numWords
			if ((partitionID + 1) * partitionSize >= numWords)
			{
				// done assigning tasks
				System.out.println("(y)done assigning");
				break;
			}
			//otherwise, keep going
		}
	}
	
	public void start ()
	{
		if (t == null)
		{
			t = new Thread (this);
			t.start ();
		}
	}
}
